# OUTPUT PART 5/Y
# Neon Gridiron ULTRA: Anti-Exploit and Explainability

# File: ai/exploit/detectors.py
import numpy as np
from typing import List, Dict

class ExploitLab:
    """
    Suite of detectors for common RL reward-hacking patterns.
    """
    def __init__(self):
        self.history: Dict[str, List[float]] = {}

    def detect_corner_stall(self, ball_pos: np.ndarray, tick: int) -> bool:
        # Detect if ball is stuck in corner for > N ticks
        # Corners: [0,0], [W,0], [0,H], [W,H]
        dist_to_corners = [np.linalg.norm(ball_pos - c) for c in [[0,0], [60,0], [0,40], [60,40]]]
        if any(d < 1.5 for d in dist_to_corners):
            return True
        return False

    def detect_ability_spam(self, ability_history: List[str]) -> float:
        # Return a "spam score" based on frequency and energy cost
        if not ability_history: return 0.0
        return len(ability_history) / 100.0 # Placeholder logic

    def generate_report(self) -> Dict[str, Any]:
        return {
            "exploits_found": 0,
            "anomaly_level": 0.1
        }
# lines: 25

# File: ai/explainability/reason_codes.py
from typing import Literal

ReasonCode = Literal[
    "XG_OPPORTUNITY", "FOUL_AVOIDANCE", "COACH_INTENT_FOLLOW",
    "COUNTER_ABILITY_DETECTED", "STAMINA_CONSERVATION", 
    "MARKING_OPPONENT", "SPACE_CREATION", "EMERGENCY_SAVE"
]

class ExplainabilityFeed:
    """
    Logs decision rationale for the UI overlays.
    """
    def __init__(self):
        self.logs = []

    def log_decision(self, tick: int, agent_id: str, code: ReasonCode, weight: float):
        self.logs.append({
            "t": tick,
            "a": agent_id,
            "c": code,
            "w": weight
        })

    def get_summary(self, start_tick: int, end_tick: int):
        return [l for l in self.logs if start_tick <= l['t'] <= end_tick]
# lines: 25

# File: telemetry/metrics_xg.py
import numpy as np

def calculate_xg(ball_pos: np.ndarray, goal_pos: np.ndarray, defenders: List[np.ndarray], angle_bonus: float) -> float:
    """
    Advanced Expected Goals (xG) calculation.
    """
    dist = np.linalg.norm(ball_pos - goal_pos)
    angle = 1.0 # Placeholder for angle-to-goal calculation
    
    # xG decreases with distance and increases with better angle
    base_xg = np.exp(-0.05 * dist) * angle * angle_bonus
    
    # Apply defender pressure penalty
    for d_pos in defenders:
        if np.linalg.norm(ball_pos - d_pos) < 2.0:
            base_xg *= 0.8
            
    return float(np.clip(base_xg, 0.01, 0.99))
# lines: 20

# File: telemetry/metrics_spectacle.py
class SpectacleAuditor:
    """
    Calculates how 'TV-ready' or exciting the match is.
    """
    def __init__(self, config: dict):
        self.w = config.get('weights', {'goal': 10, 'save': 5, 'long_pass': 2})

    def compute_score(self, events: list) -> float:
        score = 0.0
        for ev in events:
            score += self.w.get(ev.event_type.lower(), 0)
        return score
# lines: 15

# END OF PART 5 - to continue output next part.
